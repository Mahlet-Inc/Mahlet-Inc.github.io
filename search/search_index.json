{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Summary Hobbits is a software platform for analyzing, processing, and visualizing bits. The Hobbits GUI is the central tool of the platform, and will be the primary focus of this document. However, the configurability and extensibility of the analysis and processing parts of the platform make it an attractive option for \"headless\" operation (e.g. a command line utility, or an analysis/processing server.) Why? Hobbits was developed to accelerate manual data analysis tasks that were starting to burden Mahlet's hardware and software development. The de facto solution involved the use of multiple tools with slow turnaround and improvised integration (e.g. custom Python scripts and xxd.) Hobbits provided a fully integrated analysis environment without sacrificing flexibility. As a result, it has quickly accumulated success stories across the different development teams. There are tools that are similar to Hobbits, but none can claim to be as extensible, portable, and flexible. GUI and plugin binaries can be easily dropped, swapped, and executed on a variety of platforms without dependencies or restrictions. This is a priceless advantage when developing analysis tradecraft across a variety of communities, networks, or access levels. What Now? The general architecture of Hobbits has proven to be highly effective and agile, so the current development priorities are refining the GUI, and adding more plugins. Hobbits GUI The primary concern of Hobbits GUI is making machine-level data presentable to humans so that they can analyze/fix/generate it easily. This usually involves some level of processing, analysis, and visualization. One workflow could be counting the number of bytes and looking at a hex dump. Another could be performing a QAM remap, finding a data width, de-muxing, and then looking at a bit raster. Hobbits simplifies the task of developing and repeating these workflows within a single application. Capabilities All analysis, processing, and visualization capabilities of Hobbits are provided dynamically with plugins. (The plugin system is described in depth here .) While the current collection of capabilities provides a uniquely fast, easy, and portable experience, the true power of the platform lies in its ability add new plugins that further customize and optimize desired workflows. Thoughtful architectural planning has allowed several plugins to be developed within a few hours - an example plugin was even created within a few minutes during a live demo! The ease of extensibility provided by the plugin system will enable core feature development to proceed rapidly, and even opens up the possibility of externally developed plugin collections. Displays Displays are critical because the information bandwidth of the average human optical physiology is very high. Variety and configurability are necessary for showing the most important charactaristics of different types of data. Bit Raster: shows frames of bits as raster lines in which each pixel represents a bit Byte Raster: same as the Bit Raster, but each pixel represents a byte Symbol Raster: same as the Bit Raster, but each pixel is a configurable bit-length \"symbol\" with a correlating custom color Binary: shows frames of bits as lines of binary digits Hex: shows frames of bits as lines of hexadecimal digits ASCII: shows frames of bits as lines of decoded ASCII text Digraph Plot: shows byte adjacency patterns Dot Plot: shows byte repetition patterns Hilbert Plot: shows byte sections in visibly delineated chunks Frequency Plot: shows a histogram of the most common bytes Analyzers Analyzers digest and decorate the data in a way that facilitates follow-on processing and/or human evaluation. Analyzers are non-destructive. Find: finds and navigates to bit, hex, octal, and ASCII patterns in the data Width Framer: frames the data to given bit-width. Includes an auto-correlation function and width-picker graph. Kaitai Struct: highlights the data sections based on a known/specified binary format Operators Operators take some number of data inputs, and produce some number of data outputs. Most operators are 1-in, 1-out, but the flexibility of the interface enables several critical operations (e.g. data generators, muxes, demuxes.) The output of operators will go into new containers so that the original data can still be easily referenced. Take Skip: performs common bitwise pre-processing operations using a simple-yet-powerful \"take, skip\" syntax Bit Error: injects bit errors into the data LFSR: generates LFSR bits based on given parameters QAM Remapper: maps n-bit \"symbols\" to other n-bit \"symbols\" Header Framer: frames the data on a given constant header sequence Importer/Exporters Importer/Exporters are the primary way to get bitstreams in and out of hobbits. File Data: import bits from or export bits to a file on the filesystem HTTP Data: import bits from or export bits to an HTTP URL Hex String: import bits from or export bits to an ASCII string of hex characters that represent the bits TCP Data: import bits by listening for TCP data on a specified port, or export bits to a TCP server at a specified address Templates When a user develops a sequence of operations that they want to perform frequently, they can save it as a \"Template\" and perform it later with a single step. Templates can also be used to process bits on the command line with the hobbits-runner CLI. Technical Architecture The rest of this document covers the technical architecture of the Hobbits platform. Challenges The architecture of Hobbits is best understood through the lens of the challenges it faces in satisfying its user goals. Required capabilities are unpredictable The problem space that can be approached with a \"bitwise analysis, processing, and visualization\" tool is vast, even when scoped to a specific domain like high-speed networks. Hobbits must be prepared for unexpected features. Required capabilities are numerous A large problem space also leads to a large number of capabilities being integrated, and each newly integrated capability beckons adjacent capabilities to be integrated, and so on. Hobbits must be prepared for a lot of features. Required capabilities are performance-intensive When working with large amounts of data at the bit level, it is critical to use processing cycles and memory efficiently. An effective interface and core library needs to ensure that simple capabilities have efficient abstractions available, while high-performance capabilities are unencumbered by abstraction. Hobbits must provide lean interfaces and fast utilities. Implemented capabilities need to work together Decoupling capabilities from one another in a plugin system makes it harder for them to coordinate with each other and create the smoothest experience possible. Hobbits must provide ways of orchestrating multiple plugins cleanly, and the plugin interface must allow safe, opportunistic coordination between plugins. Solutions C++/Qt Using C++ and the Qt framework as the foundation for Hobbits makes it easier to meet performance requirements, and trivializes the process of turning existing C/C++ programs into plugins. This is useful because many performance-critical data analysis and processing capabilities are written in C/C++. Qt enables rapid GUI design as well as a variety of well-documented convenience tools, such as a plugin loading system. Plugin System As mentioned above, all analysis, processing, and visualization capabilities of Hobbits are provided dynamically with plugins. This makes it easy to add new and unexpected capabilities without increasing the complexity of adding more new and unexpected capabilities. This kind of development scaling can be achieved without plugins, but plugins guarantee it. Furthemore, plugins enable the program to be extended without any updates to the core program. The plugin interfaces grant a lot of implementation flexibility while maintaining a narrow, inflexible coupling to the core program. The flexibility enables the addition of unpredictable capabilities, while the clear coupling enables useful integration between plugins. Another important consideration of the plugin system design was implementation speed and ease. Adding new plugins needs to be fast and painless. The simplicity of the essential interface components helps with this, but the core library utilities and the plugin templates are also very important. Finally, a plugin system allows Mahlet (or any other organization) to develop plugins that can be used internally, or licensed and sold separately from the core Hobbits open-source project. Core Library The core library's main purpose is to provide useful tools and abstractions for the plugin implementations. This includes ways of accessing and operating on packed bits, and partial implementations of common plugin types (e.g. displays that show zoomable characters,) among other conveniences. The core library also contains useful capabilities for managing the integration of different plugins in a sensible way. The Hobbits GUI relies heavily on these default integration managers, and as a result is less than 1000 lines of code. Other applications would be able to similarly leverage the core library, so custom Hobbits command line utilities and processing servers could feasibly be created (or added to existing programs) in a matter of hours rather than days/weeks. Templates Even with rigorous simplification of the plugin interfaces and useful abstractions of the Qt plugin loader, there is still a small amount of boilerplate code required when making a plugin. This boilerplate code can be annoying to experienced developers, and it can be intimidating to developers that are unfamiliar with the program. Templates, in the form of Qt Creator wizards, are available to set up all of the boilerplate code required to make a functioning plugin. This dramatically speeds up the development of new plugins, especially simple plugins, and plugins that just wrap existing C/C++ processing capabilities.","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#summary","text":"Hobbits is a software platform for analyzing, processing, and visualizing bits. The Hobbits GUI is the central tool of the platform, and will be the primary focus of this document. However, the configurability and extensibility of the analysis and processing parts of the platform make it an attractive option for \"headless\" operation (e.g. a command line utility, or an analysis/processing server.)","title":"Summary"},{"location":"#why","text":"Hobbits was developed to accelerate manual data analysis tasks that were starting to burden Mahlet's hardware and software development. The de facto solution involved the use of multiple tools with slow turnaround and improvised integration (e.g. custom Python scripts and xxd.) Hobbits provided a fully integrated analysis environment without sacrificing flexibility. As a result, it has quickly accumulated success stories across the different development teams. There are tools that are similar to Hobbits, but none can claim to be as extensible, portable, and flexible. GUI and plugin binaries can be easily dropped, swapped, and executed on a variety of platforms without dependencies or restrictions. This is a priceless advantage when developing analysis tradecraft across a variety of communities, networks, or access levels.","title":"Why?"},{"location":"#what-now","text":"The general architecture of Hobbits has proven to be highly effective and agile, so the current development priorities are refining the GUI, and adding more plugins.","title":"What Now?"},{"location":"#hobbits-gui","text":"The primary concern of Hobbits GUI is making machine-level data presentable to humans so that they can analyze/fix/generate it easily. This usually involves some level of processing, analysis, and visualization. One workflow could be counting the number of bytes and looking at a hex dump. Another could be performing a QAM remap, finding a data width, de-muxing, and then looking at a bit raster. Hobbits simplifies the task of developing and repeating these workflows within a single application.","title":"Hobbits GUI"},{"location":"#capabilities","text":"All analysis, processing, and visualization capabilities of Hobbits are provided dynamically with plugins. (The plugin system is described in depth here .) While the current collection of capabilities provides a uniquely fast, easy, and portable experience, the true power of the platform lies in its ability add new plugins that further customize and optimize desired workflows. Thoughtful architectural planning has allowed several plugins to be developed within a few hours - an example plugin was even created within a few minutes during a live demo! The ease of extensibility provided by the plugin system will enable core feature development to proceed rapidly, and even opens up the possibility of externally developed plugin collections.","title":"Capabilities"},{"location":"#displays","text":"Displays are critical because the information bandwidth of the average human optical physiology is very high. Variety and configurability are necessary for showing the most important charactaristics of different types of data. Bit Raster: shows frames of bits as raster lines in which each pixel represents a bit Byte Raster: same as the Bit Raster, but each pixel represents a byte Symbol Raster: same as the Bit Raster, but each pixel is a configurable bit-length \"symbol\" with a correlating custom color Binary: shows frames of bits as lines of binary digits Hex: shows frames of bits as lines of hexadecimal digits ASCII: shows frames of bits as lines of decoded ASCII text Digraph Plot: shows byte adjacency patterns Dot Plot: shows byte repetition patterns Hilbert Plot: shows byte sections in visibly delineated chunks Frequency Plot: shows a histogram of the most common bytes","title":"Displays"},{"location":"#analyzers","text":"Analyzers digest and decorate the data in a way that facilitates follow-on processing and/or human evaluation. Analyzers are non-destructive. Find: finds and navigates to bit, hex, octal, and ASCII patterns in the data Width Framer: frames the data to given bit-width. Includes an auto-correlation function and width-picker graph. Kaitai Struct: highlights the data sections based on a known/specified binary format","title":"Analyzers"},{"location":"#operators","text":"Operators take some number of data inputs, and produce some number of data outputs. Most operators are 1-in, 1-out, but the flexibility of the interface enables several critical operations (e.g. data generators, muxes, demuxes.) The output of operators will go into new containers so that the original data can still be easily referenced. Take Skip: performs common bitwise pre-processing operations using a simple-yet-powerful \"take, skip\" syntax Bit Error: injects bit errors into the data LFSR: generates LFSR bits based on given parameters QAM Remapper: maps n-bit \"symbols\" to other n-bit \"symbols\" Header Framer: frames the data on a given constant header sequence","title":"Operators"},{"location":"#importerexporters","text":"Importer/Exporters are the primary way to get bitstreams in and out of hobbits. File Data: import bits from or export bits to a file on the filesystem HTTP Data: import bits from or export bits to an HTTP URL Hex String: import bits from or export bits to an ASCII string of hex characters that represent the bits TCP Data: import bits by listening for TCP data on a specified port, or export bits to a TCP server at a specified address","title":"Importer/Exporters"},{"location":"#templates","text":"When a user develops a sequence of operations that they want to perform frequently, they can save it as a \"Template\" and perform it later with a single step. Templates can also be used to process bits on the command line with the hobbits-runner CLI.","title":"Templates"},{"location":"#technical-architecture","text":"The rest of this document covers the technical architecture of the Hobbits platform.","title":"Technical Architecture"},{"location":"#challenges","text":"The architecture of Hobbits is best understood through the lens of the challenges it faces in satisfying its user goals.","title":"Challenges"},{"location":"#required-capabilities-are-unpredictable","text":"The problem space that can be approached with a \"bitwise analysis, processing, and visualization\" tool is vast, even when scoped to a specific domain like high-speed networks. Hobbits must be prepared for unexpected features.","title":"Required capabilities are unpredictable"},{"location":"#required-capabilities-are-numerous","text":"A large problem space also leads to a large number of capabilities being integrated, and each newly integrated capability beckons adjacent capabilities to be integrated, and so on. Hobbits must be prepared for a lot of features.","title":"Required capabilities are numerous"},{"location":"#required-capabilities-are-performance-intensive","text":"When working with large amounts of data at the bit level, it is critical to use processing cycles and memory efficiently. An effective interface and core library needs to ensure that simple capabilities have efficient abstractions available, while high-performance capabilities are unencumbered by abstraction. Hobbits must provide lean interfaces and fast utilities.","title":"Required capabilities are performance-intensive"},{"location":"#implemented-capabilities-need-to-work-together","text":"Decoupling capabilities from one another in a plugin system makes it harder for them to coordinate with each other and create the smoothest experience possible. Hobbits must provide ways of orchestrating multiple plugins cleanly, and the plugin interface must allow safe, opportunistic coordination between plugins.","title":"Implemented capabilities need to work together"},{"location":"#solutions","text":"","title":"Solutions"},{"location":"#cqt","text":"Using C++ and the Qt framework as the foundation for Hobbits makes it easier to meet performance requirements, and trivializes the process of turning existing C/C++ programs into plugins. This is useful because many performance-critical data analysis and processing capabilities are written in C/C++. Qt enables rapid GUI design as well as a variety of well-documented convenience tools, such as a plugin loading system.","title":"C++/Qt"},{"location":"#plugin-system","text":"As mentioned above, all analysis, processing, and visualization capabilities of Hobbits are provided dynamically with plugins. This makes it easy to add new and unexpected capabilities without increasing the complexity of adding more new and unexpected capabilities. This kind of development scaling can be achieved without plugins, but plugins guarantee it. Furthemore, plugins enable the program to be extended without any updates to the core program. The plugin interfaces grant a lot of implementation flexibility while maintaining a narrow, inflexible coupling to the core program. The flexibility enables the addition of unpredictable capabilities, while the clear coupling enables useful integration between plugins. Another important consideration of the plugin system design was implementation speed and ease. Adding new plugins needs to be fast and painless. The simplicity of the essential interface components helps with this, but the core library utilities and the plugin templates are also very important. Finally, a plugin system allows Mahlet (or any other organization) to develop plugins that can be used internally, or licensed and sold separately from the core Hobbits open-source project.","title":"Plugin System"},{"location":"#core-library","text":"The core library's main purpose is to provide useful tools and abstractions for the plugin implementations. This includes ways of accessing and operating on packed bits, and partial implementations of common plugin types (e.g. displays that show zoomable characters,) among other conveniences. The core library also contains useful capabilities for managing the integration of different plugins in a sensible way. The Hobbits GUI relies heavily on these default integration managers, and as a result is less than 1000 lines of code. Other applications would be able to similarly leverage the core library, so custom Hobbits command line utilities and processing servers could feasibly be created (or added to existing programs) in a matter of hours rather than days/weeks.","title":"Core Library"},{"location":"#templates_1","text":"Even with rigorous simplification of the plugin interfaces and useful abstractions of the Qt plugin loader, there is still a small amount of boilerplate code required when making a plugin. This boilerplate code can be annoying to experienced developers, and it can be intimidating to developers that are unfamiliar with the program. Templates, in the form of Qt Creator wizards, are available to set up all of the boilerplate code required to make a functioning plugin. This dramatically speeds up the development of new plugins, especially simple plugins, and plugins that just wrap existing C/C++ processing capabilities.","title":"Templates"},{"location":"plugin-developer-guide/","text":"Hobbits Plugin Development The Hobbits framework is designed to coordinate the capabilities of various plugins into a smooth, cohesive experience. The plugins are where all of the \"actual work\" gets done. There are currently four types of plugins in Hobbits: Displays, Analyzers, Operators, and Importer/Exporters. This document will cover general plugin implementation concepts, and then walk through the development process for each type of plugin. Example Plugin Development Video General Terms and Concepts Qt Plugin API Hobbits leverages the low-level plugin API provided by Qt for its plugin system. Refer to the following Qt documentation for details: Low-level Plugin API Deploying Plugins Bit Containers The BitContainer class is the primary means of storing data, and sharing it between plugins. A BitContainer holds binary data, as well as metadata such as how that data is framed. It also keeps a record of any changes that have been made to it by Hobbits plugins. The binary data is held in a BitArray , which abstracts byte boundaries from the user, and has a modest-but-growing assortment of performance efficiencies and helper functions. Metadata is stored in a BitInfo object which is read and written with the bitInfo and setBitInfo methods. The framing of a bitstream is an important part of its metadata for display and processing purposes. The frames of a BitContainer can be set in the BitInfo::setFrames method. General purpose metadata can be set with BitInfo::setMetadata and read with BitInfo::metadata . Plugins can use container metadata as a general purpose bus for communicating with other plugins, or even as a cache for their own purposes. For example, the \"Find\" Analyzer plugin stores the results of a find operation in a container's metadata so that when that container loses focus, the information will still be available when the container comes back into focus. Highlights are a separate kind of metadata that deal with ranges of bits within a bit container. They are read and written with various functions including BitInfo::addHighlights and BitInfo::highlights , and they are stored as a map of strings to RangeHighlight lists. The \"Find\" Analyzer plugin sets highlights in the ranges where it finds its search string, and several Display plugins check for the existence and colors of RangeHighlight s in order to render visual highlights across those ranges. Plugins like the Extractor operator use RangeHighlight s for their processing. Analyzer plugins do not have write access to bit containers, so they cannot edit the BitInfo directly. As a result, they must include a container's updated BitInfo in the AnalyzerResult s that they return. Common Plugin Interface Methods All of the plugin interfaces have a getName method that must return the name of that plugin as it should appear to the user. The name must be unique. There is also a common createDefaultX method (where X is the interface type) that simply returns a default instance of the plugin. The Analyzer and Operator interfaces have several simple methods in common: applyToWidget initializes the plugin's UI on a given widget provideCallback gives the plugin a PluginCallback instance that can be used to request that it gets executed (this is useful because the central application that triggers plugin execution is decoupled from the plugin's UI, so in order for a plugin to trigger execution when, for example, the \"Enter\" key is pressed in its UI form, it needs to relay this request through the PluginCallback instance it is given.) getStateFromUi gets the plugin's current state/configuration based on how its UI is filled out. If there are invalid or incomplete entries, the plugin can return an empty state to indicate that it is not ready for execution. setPluginStateInUi (conversely from getStateFromUI ) is given a pluginState, and it must fill out the UI in a way that would return that state if getStateFromUi were called immediately afterwards canRecallPluginState checks a plugin state to see if it can be used to execute the plugin. If the state is empty or incomplete, it must return false. previewBits takes a read-only bit container and it can be used to prepare the plugin for execution or enhance the UI options it presents. The Width Framer analyzer plugins generates auto-correlation data in the previewBits method, which is used to display a width-selector graph with suggested widths. It is fine to leave this method's implementation empty. Plugin State The plugin state contains parameters for how the plugin should run. For example, the Take Skip operator plugin will require a \"take_skip_string\" parameter to guide its execution. The state that it passed in can be provided by the plugin's own getStateFromUi method, or it can come from a saved template that was generated from a state returned by a plugin result ( OperatorResult or AnalyzerResult .) Plugin results will usually just return the state that was passed in (e.g. AnalyzerResult::result(bitInfo, recallablePluginState) ,) but sometimes that state needs to be enriched with execution details that were added by the plugin, such as a random number seed, so that the execution can be duplicated exactly with the returned state. Action Progress The ActionProgress parameter is passed to the primary methods of the operator and analyzer interfaces. It allows a plugin to report its percentage progress as it executes, and allows it to check if it has been cancelled so that it can halt execution gracefully. Specific Interfaces Operator Interface Operators take some number of data inputs, and produce some number of data outputs. Most operators are 1-in, 1-out, but the flexibility of the interface enables several critical operations (e.g. data generators, muxes, demuxes.) The output of operators will go into new containers so that the original data can still be easily referenced. operateOnContainers takes a list of read-only bit containers, a plugin state, and an ActionProgress instance. It returns an OperatorResult which contains any new bit containers that have been created by the operator, and the plugin state that will enable the operation to be duplicated exactly (see plugin state details above .) operateOnContainers might run in a separate thread from the main GUI thread, so you cannot use Qt features that depend on being in the main thread, e.g., showing a QMessageBox. getMinInputContainers and getMaxInputContainers return the minimum and maximum number of containers that the operator accepts as inputs. Operators that take a single input and produce a single output would simply return 1 for both of these functions. Analyzer Interface Analyzers digest and decorate the data in a way that facilitates follow-on processing and/or human evaluation. analyzeBits takes a read-only bit container, a plugin state, and an ActionProgress instance. It returns an AnalyzerResult which contains new general metadata and range entries for the container, and the plugin state that will enable the operation to be duplicated exactly (see plugin state details above .) analyzeBits might run in a separate thread from the main GUI thread, so you cannot use Qt features that depend on being in the main thread, e.g., showing a QMessageBox. Display Interface Displays show the data in some sort of useful format (e.g. a bit raster, or a hex dump.) They can use metadata and highlights in bit containers to augment a depiction of the data, but they could also show only the metadata if that was useful somehow (e.g. if there were some metrics worth presenting separately from the plugin that generated them.) getDisplayWidget and getControlsWidget provide the display and (optional) controls for a display plugin. They both take a DisplayHandle as their sole parameter. The DisplayHandle provides access to a variety of things that a display might need to access (e.g. the current bit container), or set (e.g. the bit that is currently being hovered over by the mouse.) Import/Export Interface Import/Export plugins import and/or export bit containers for use in Hobbits. The simplest of these plugins is the \"File Data\" plugin that imports/exports raw binary data from/to files. canExport and canImport return a boolean value indicating whether or not the plugin is capable of importing or exporting (e.g. you might want a plugin that can import data but not export it.) You can return false in both methods, but that would be impolite. importBits and exportBits both receive a map of arguments (which might be empty) and a pointer to a QWidget that should be used as the parent to any GUI elements generated by the plugin (e.g. a file dialog.) exportBits also receives a bit container that should be exported. importBits returns a non-empty bit container if it was successful at importing data. Helpful Tools In order to simplify the process of developing plugins, there are Qt Creator wizards that take care of most of the boilerplate code. The wizards can be installed using the wizard_installer.sh script. Get in touch If you are having trouble making a plugin, or if you have a suggestion for the hobbits API or documentation please open an issue on the GitHub page or ask about it on the Discord channel","title":"Plugin Developer Guide"},{"location":"plugin-developer-guide/#hobbits-plugin-development","text":"The Hobbits framework is designed to coordinate the capabilities of various plugins into a smooth, cohesive experience. The plugins are where all of the \"actual work\" gets done. There are currently four types of plugins in Hobbits: Displays, Analyzers, Operators, and Importer/Exporters. This document will cover general plugin implementation concepts, and then walk through the development process for each type of plugin.","title":"Hobbits Plugin Development"},{"location":"plugin-developer-guide/#example-plugin-development-video","text":"","title":"Example Plugin Development Video"},{"location":"plugin-developer-guide/#general-terms-and-concepts","text":"","title":"General Terms and Concepts"},{"location":"plugin-developer-guide/#qt-plugin-api","text":"Hobbits leverages the low-level plugin API provided by Qt for its plugin system. Refer to the following Qt documentation for details: Low-level Plugin API Deploying Plugins","title":"Qt Plugin API"},{"location":"plugin-developer-guide/#bit-containers","text":"The BitContainer class is the primary means of storing data, and sharing it between plugins. A BitContainer holds binary data, as well as metadata such as how that data is framed. It also keeps a record of any changes that have been made to it by Hobbits plugins. The binary data is held in a BitArray , which abstracts byte boundaries from the user, and has a modest-but-growing assortment of performance efficiencies and helper functions. Metadata is stored in a BitInfo object which is read and written with the bitInfo and setBitInfo methods. The framing of a bitstream is an important part of its metadata for display and processing purposes. The frames of a BitContainer can be set in the BitInfo::setFrames method. General purpose metadata can be set with BitInfo::setMetadata and read with BitInfo::metadata . Plugins can use container metadata as a general purpose bus for communicating with other plugins, or even as a cache for their own purposes. For example, the \"Find\" Analyzer plugin stores the results of a find operation in a container's metadata so that when that container loses focus, the information will still be available when the container comes back into focus. Highlights are a separate kind of metadata that deal with ranges of bits within a bit container. They are read and written with various functions including BitInfo::addHighlights and BitInfo::highlights , and they are stored as a map of strings to RangeHighlight lists. The \"Find\" Analyzer plugin sets highlights in the ranges where it finds its search string, and several Display plugins check for the existence and colors of RangeHighlight s in order to render visual highlights across those ranges. Plugins like the Extractor operator use RangeHighlight s for their processing. Analyzer plugins do not have write access to bit containers, so they cannot edit the BitInfo directly. As a result, they must include a container's updated BitInfo in the AnalyzerResult s that they return.","title":"Bit Containers"},{"location":"plugin-developer-guide/#common-plugin-interface-methods","text":"All of the plugin interfaces have a getName method that must return the name of that plugin as it should appear to the user. The name must be unique. There is also a common createDefaultX method (where X is the interface type) that simply returns a default instance of the plugin. The Analyzer and Operator interfaces have several simple methods in common: applyToWidget initializes the plugin's UI on a given widget provideCallback gives the plugin a PluginCallback instance that can be used to request that it gets executed (this is useful because the central application that triggers plugin execution is decoupled from the plugin's UI, so in order for a plugin to trigger execution when, for example, the \"Enter\" key is pressed in its UI form, it needs to relay this request through the PluginCallback instance it is given.) getStateFromUi gets the plugin's current state/configuration based on how its UI is filled out. If there are invalid or incomplete entries, the plugin can return an empty state to indicate that it is not ready for execution. setPluginStateInUi (conversely from getStateFromUI ) is given a pluginState, and it must fill out the UI in a way that would return that state if getStateFromUi were called immediately afterwards canRecallPluginState checks a plugin state to see if it can be used to execute the plugin. If the state is empty or incomplete, it must return false. previewBits takes a read-only bit container and it can be used to prepare the plugin for execution or enhance the UI options it presents. The Width Framer analyzer plugins generates auto-correlation data in the previewBits method, which is used to display a width-selector graph with suggested widths. It is fine to leave this method's implementation empty.","title":"Common Plugin Interface Methods"},{"location":"plugin-developer-guide/#plugin-state","text":"The plugin state contains parameters for how the plugin should run. For example, the Take Skip operator plugin will require a \"take_skip_string\" parameter to guide its execution. The state that it passed in can be provided by the plugin's own getStateFromUi method, or it can come from a saved template that was generated from a state returned by a plugin result ( OperatorResult or AnalyzerResult .) Plugin results will usually just return the state that was passed in (e.g. AnalyzerResult::result(bitInfo, recallablePluginState) ,) but sometimes that state needs to be enriched with execution details that were added by the plugin, such as a random number seed, so that the execution can be duplicated exactly with the returned state.","title":"Plugin State"},{"location":"plugin-developer-guide/#action-progress","text":"The ActionProgress parameter is passed to the primary methods of the operator and analyzer interfaces. It allows a plugin to report its percentage progress as it executes, and allows it to check if it has been cancelled so that it can halt execution gracefully.","title":"Action Progress"},{"location":"plugin-developer-guide/#specific-interfaces","text":"","title":"Specific Interfaces"},{"location":"plugin-developer-guide/#operator-interface","text":"Operators take some number of data inputs, and produce some number of data outputs. Most operators are 1-in, 1-out, but the flexibility of the interface enables several critical operations (e.g. data generators, muxes, demuxes.) The output of operators will go into new containers so that the original data can still be easily referenced. operateOnContainers takes a list of read-only bit containers, a plugin state, and an ActionProgress instance. It returns an OperatorResult which contains any new bit containers that have been created by the operator, and the plugin state that will enable the operation to be duplicated exactly (see plugin state details above .) operateOnContainers might run in a separate thread from the main GUI thread, so you cannot use Qt features that depend on being in the main thread, e.g., showing a QMessageBox. getMinInputContainers and getMaxInputContainers return the minimum and maximum number of containers that the operator accepts as inputs. Operators that take a single input and produce a single output would simply return 1 for both of these functions.","title":"Operator Interface"},{"location":"plugin-developer-guide/#analyzer-interface","text":"Analyzers digest and decorate the data in a way that facilitates follow-on processing and/or human evaluation. analyzeBits takes a read-only bit container, a plugin state, and an ActionProgress instance. It returns an AnalyzerResult which contains new general metadata and range entries for the container, and the plugin state that will enable the operation to be duplicated exactly (see plugin state details above .) analyzeBits might run in a separate thread from the main GUI thread, so you cannot use Qt features that depend on being in the main thread, e.g., showing a QMessageBox.","title":"Analyzer Interface"},{"location":"plugin-developer-guide/#display-interface","text":"Displays show the data in some sort of useful format (e.g. a bit raster, or a hex dump.) They can use metadata and highlights in bit containers to augment a depiction of the data, but they could also show only the metadata if that was useful somehow (e.g. if there were some metrics worth presenting separately from the plugin that generated them.) getDisplayWidget and getControlsWidget provide the display and (optional) controls for a display plugin. They both take a DisplayHandle as their sole parameter. The DisplayHandle provides access to a variety of things that a display might need to access (e.g. the current bit container), or set (e.g. the bit that is currently being hovered over by the mouse.)","title":"Display Interface"},{"location":"plugin-developer-guide/#importexport-interface","text":"Import/Export plugins import and/or export bit containers for use in Hobbits. The simplest of these plugins is the \"File Data\" plugin that imports/exports raw binary data from/to files. canExport and canImport return a boolean value indicating whether or not the plugin is capable of importing or exporting (e.g. you might want a plugin that can import data but not export it.) You can return false in both methods, but that would be impolite. importBits and exportBits both receive a map of arguments (which might be empty) and a pointer to a QWidget that should be used as the parent to any GUI elements generated by the plugin (e.g. a file dialog.) exportBits also receives a bit container that should be exported. importBits returns a non-empty bit container if it was successful at importing data.","title":"Import/Export Interface"},{"location":"plugin-developer-guide/#helpful-tools","text":"In order to simplify the process of developing plugins, there are Qt Creator wizards that take care of most of the boilerplate code. The wizards can be installed using the wizard_installer.sh script.","title":"Helpful Tools"},{"location":"plugin-developer-guide/#get-in-touch","text":"If you are having trouble making a plugin, or if you have a suggestion for the hobbits API or documentation please open an issue on the GitHub page or ask about it on the Discord channel","title":"Get in touch"},{"location":"user-guide/","text":"Using the Hobbits GUI The Hobbits GUI is a powerful tool for manually evaluating data. It provides a fully integrated set of tools for preprocessing, analyzing, and displaying data in a variety of ways. This guide explains how to use the different features of the Hobbits GUI, and then presents a few example workflows. Example Usage Video GUI Layout Bit Container Selection Panel Displays Analyzer Panel Controls for the Displays Operator Panel Preferences Menu Navigating to Edit->Preferences... opens the preferences dialog where the application configuration can be viewed and edited. Bit Containers Hobbits organizes imported data into \"bit containers\" that appear in a collapsible panel on the left side of the GUI by default. The panel's visibility can be toggled via: The top menu at View->Bit Containers The Ctrl-Shift-B hotkey The x at the top right corner of the panel (only for hiding) Bit containers keep track of the data as well as metadata that can be extended, modified, and read by plugins. An important part of this metadata is the \"frames\" that the data is subdivided into. For example, when looking at time-division multiplexed data in a bit raster, it is useful to have each multiplexer frame on its own line so that constants, counters, and other patterns can be easily identified. Plugins Displays One of the most prominent features of the GUI is the variety of displays that it provides for looking at data. Switching between displays is as simple as selecting the tab of the display that you want to use. Your position in the data is preserved across displays, so you can navigate to a section of your data in one display, and then switch tabs to see what that section looks like in a different display. Displays can also be split so that you can look at more than one display at the same time. Split views can be added or removed via: The top menu in View->Split View The Ctrl-Shift-V hotkey adds a view to the right The Ctrl-Shift-X hotkey removes the rightmost view Operators Operators are displayed in a collapsible panel that appears at the bottom of the GUI by default. The panel's visibility can be toggled via: The top menu at View->Operator Plugins The Ctrl-Shift-O hotkey The x at the top right corner of the panel (only for hiding) Operators can be used to modify, generate, combine, or separate data. A commonly used operator is the Take Skip Operator, which allows you to quickly process data with a simple filtering expression. For example, if you have data that is uninteresting for the first 50 bits of every 256-bit frame, you can perform a s50t206 to skip 50 bits and then take 206 bits for each frame so that you are only left with the last 206 bits of each frame for further evaluation. When an operator modifies data, the original data is still available to work with. Analyzers Analyzers appear in a collapsible panel on the right side of the GUI by default. The panel's visibility can be toggled via: The top menu at View->Analyzer Plugins The Ctrl-A hotkey The x at the top right corner of the panel (only for hiding) Analyzers provide useful information about the data, and can add that information to the current bit container's metadata. For example, you can use the Width Framer to discover appropriate frame widths for data, and then apply one of those widths to the container. You can use the Find analyzer to find instances of bit/byte/ASCII sequences in data, and then highlight and quickly navigate to them. Importer/Exporters Importer/Exporters appear in the File->Import Bits From and File->Export Bits To menus. Importer/Exporters are the primary way to get bitstreams in and out of hobbits. For example, if you want to open a file as bits, selecting the File Data import plugin will let you select a file and then load it in as a Bit Container. Command line execution When running Hobbits from the command line, a variety of configuration and data loading options are provided. Simply run it with the --help option to see which options are available. The hobbits-runner program can be used to apply a saved Hobbits template to an input file without needing to open the GUI. Plugin loading A standard Hobbits distributable binary comes with a set of core plugins that should load without any user configuration. However, if you want to use a plugin that is not part of the core distribution, you can either: add it to the appropriate directory in the plugins folder of the distribution folder or ~/.local/share/hobbits/plugins or, use the --extra-plugin-path command line option to specify a folder with non-core plugins in it (remember that a valid plugins folder has analyzers, displays, and operators in their own sub-folders, e.g. my-plugins/displays .) or, specify your plugin path in your GUI config. In Linux, the config is an ini file that can be found at ~/.config/Hobbits/Hobbits GUI.conf , and the plugin path configuration is the path variable in the [Plugins] section. Get in touch If you are having trouble using hobbits, or if you have a suggestion for hobbits or the documentation, please open an issue on the GitHub page or ask about it on the Discord channel","title":"User Guide"},{"location":"user-guide/#using-the-hobbits-gui","text":"The Hobbits GUI is a powerful tool for manually evaluating data. It provides a fully integrated set of tools for preprocessing, analyzing, and displaying data in a variety of ways. This guide explains how to use the different features of the Hobbits GUI, and then presents a few example workflows.","title":"Using the Hobbits GUI"},{"location":"user-guide/#example-usage-video","text":"","title":"Example Usage Video"},{"location":"user-guide/#gui-layout","text":"Bit Container Selection Panel Displays Analyzer Panel Controls for the Displays Operator Panel","title":"GUI Layout"},{"location":"user-guide/#preferences-menu","text":"Navigating to Edit->Preferences... opens the preferences dialog where the application configuration can be viewed and edited.","title":"Preferences Menu"},{"location":"user-guide/#bit-containers","text":"Hobbits organizes imported data into \"bit containers\" that appear in a collapsible panel on the left side of the GUI by default. The panel's visibility can be toggled via: The top menu at View->Bit Containers The Ctrl-Shift-B hotkey The x at the top right corner of the panel (only for hiding) Bit containers keep track of the data as well as metadata that can be extended, modified, and read by plugins. An important part of this metadata is the \"frames\" that the data is subdivided into. For example, when looking at time-division multiplexed data in a bit raster, it is useful to have each multiplexer frame on its own line so that constants, counters, and other patterns can be easily identified.","title":"Bit Containers"},{"location":"user-guide/#plugins","text":"","title":"Plugins"},{"location":"user-guide/#displays","text":"One of the most prominent features of the GUI is the variety of displays that it provides for looking at data. Switching between displays is as simple as selecting the tab of the display that you want to use. Your position in the data is preserved across displays, so you can navigate to a section of your data in one display, and then switch tabs to see what that section looks like in a different display. Displays can also be split so that you can look at more than one display at the same time. Split views can be added or removed via: The top menu in View->Split View The Ctrl-Shift-V hotkey adds a view to the right The Ctrl-Shift-X hotkey removes the rightmost view","title":"Displays"},{"location":"user-guide/#operators","text":"Operators are displayed in a collapsible panel that appears at the bottom of the GUI by default. The panel's visibility can be toggled via: The top menu at View->Operator Plugins The Ctrl-Shift-O hotkey The x at the top right corner of the panel (only for hiding) Operators can be used to modify, generate, combine, or separate data. A commonly used operator is the Take Skip Operator, which allows you to quickly process data with a simple filtering expression. For example, if you have data that is uninteresting for the first 50 bits of every 256-bit frame, you can perform a s50t206 to skip 50 bits and then take 206 bits for each frame so that you are only left with the last 206 bits of each frame for further evaluation. When an operator modifies data, the original data is still available to work with.","title":"Operators"},{"location":"user-guide/#analyzers","text":"Analyzers appear in a collapsible panel on the right side of the GUI by default. The panel's visibility can be toggled via: The top menu at View->Analyzer Plugins The Ctrl-A hotkey The x at the top right corner of the panel (only for hiding) Analyzers provide useful information about the data, and can add that information to the current bit container's metadata. For example, you can use the Width Framer to discover appropriate frame widths for data, and then apply one of those widths to the container. You can use the Find analyzer to find instances of bit/byte/ASCII sequences in data, and then highlight and quickly navigate to them.","title":"Analyzers"},{"location":"user-guide/#importerexporters","text":"Importer/Exporters appear in the File->Import Bits From and File->Export Bits To menus. Importer/Exporters are the primary way to get bitstreams in and out of hobbits. For example, if you want to open a file as bits, selecting the File Data import plugin will let you select a file and then load it in as a Bit Container.","title":"Importer/Exporters"},{"location":"user-guide/#command-line-execution","text":"When running Hobbits from the command line, a variety of configuration and data loading options are provided. Simply run it with the --help option to see which options are available. The hobbits-runner program can be used to apply a saved Hobbits template to an input file without needing to open the GUI.","title":"Command line execution"},{"location":"user-guide/#plugin-loading","text":"A standard Hobbits distributable binary comes with a set of core plugins that should load without any user configuration. However, if you want to use a plugin that is not part of the core distribution, you can either: add it to the appropriate directory in the plugins folder of the distribution folder or ~/.local/share/hobbits/plugins or, use the --extra-plugin-path command line option to specify a folder with non-core plugins in it (remember that a valid plugins folder has analyzers, displays, and operators in their own sub-folders, e.g. my-plugins/displays .) or, specify your plugin path in your GUI config. In Linux, the config is an ini file that can be found at ~/.config/Hobbits/Hobbits GUI.conf , and the plugin path configuration is the path variable in the [Plugins] section.","title":"Plugin loading"},{"location":"user-guide/#get-in-touch","text":"If you are having trouble using hobbits, or if you have a suggestion for hobbits or the documentation, please open an issue on the GitHub page or ask about it on the Discord channel","title":"Get in touch"}]}