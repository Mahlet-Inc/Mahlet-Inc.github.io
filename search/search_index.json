{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Summary Hobbits is a software platform for analyzing, processing, and visualizing bits. The Hobbits GUI is the central tool of the platform, and will be the primary focus of this document. The Hobbits Runner CLI enables the execution of plugins and batches without a GUI. Why? Hobbits was developed to accelerate manual data analysis tasks that were starting to burden Mahlet's hardware and software development. The de facto solution involved the use of multiple tools with slow turnaround and improvised integration (e.g. custom Python scripts and xxd.) Hobbits provided a fully integrated analysis environment without sacrificing flexibility. As a result, it has quickly accumulated success stories across the different development teams. There are tools that are similar to Hobbits, but none can claim to be as extensible, portable, and flexible. GUI and plugin binaries can be easily dropped, swapped, and executed on a variety of platforms without dependencies or restrictions. Hobbits even supports pure Python plugins via a built-in CPython interpreter and custom hobbits library bindings. These are all priceless advantages when developing analysis tradecraft across a variety of communities, networks, or access levels. What Now? The general architecture of Hobbits has proven to be highly effective and agile, and the budding Python capabilities are promising. With a stable interface in place, the development priorities will shift to core stability and performance, adding and improving plugins, and exploring the possibilities of distributed and client-server architectures. Hobbits GUI The primary concern of Hobbits GUI is making machine-level data presentable to humans so that they can analyze/fix/generate it easily. This usually involves some combination of: Importing bits, e.g. from files, packets, or a radio interface Analyzing bits, e.g. framing, highlighting, or classifying Displaying bits so that a human can understand them Processing bits, e.g. enriching, decoding, or demuxing them Exporting bits, e.g. saving a file, or forwarding to follow-on processes Hobbits simplifies the task of developing and repeating workflows comprised of these steps. Steps are developed independently as plugins, and Hobbits orchestrates their execution. Capabilities Via Plugins The importing, analyzing, displaying, processing, and exporting capabilities of Hobbits are provided dynamically with plugins. (The plugin system is described in depth here .) While the current collection of capabilities provides a uniquely fast, easy, and portable experience, the true power of the platform lies in its ability add new plugins that further customize and optimize desired workflows. Thoughtful architectural planning and useful development tools allow one to create plugins with C++ or Python in a matter of minutes. The ease of extensibility provided by the plugin system will enable core feature development to proceed rapidly, and even opens up the possibility of externally developed plugin collections. Displays Displays are critical because the information bandwidth of the average human optical physiology is very high. Variety and configurability are necessary for showing the most important charactaristics of different types of data. Bit Raster: shows frames of bits as raster lines in which each pixel represents a bit Byte Raster: same as the Bit Raster, but each pixel represents a byte Symbol Raster: same as the Bit Raster, but each pixel is a configurable bit-length \"symbol\" with a correlating custom color Binary: shows frames of bits as lines of binary digits Hex: shows frames of bits as lines of hexadecimal digits ASCII: shows frames of bits as lines of decoded ASCII text Digraph Plot: shows byte adjacency patterns Dot Plot: shows byte repetition patterns Hilbert Plot: shows byte sections in visibly delineated chunks Frequency Plot: shows a histogram of the most common bytes Spectrogram: shows a power spectral density waterfall plot for sampled data Analyzers Analyzers digest and decorate the data in a way that facilitates follow-on processing and/or human evaluation. Analyzers are non-destructive. Find: finds and navigates to bit, hex, octal, and ASCII patterns in the data Width Framer: frames the data to given bit-width. Includes an auto-correlation function and width-picker graph. Highlight: enables highlighting of bit ranges Kaitai Struct: highlights the data sections based on a known/specified binary format Metadata: shows and allows editing of metadata fields Operators Operators take some number of data inputs, and produce some number of data outputs. Most operators are 1-in, 1-out, but the flexibility of the interface enables several critical operations (e.g. muxes, demuxes.) The output of operators will go into new containers so that the original data can still be easily referenced. Take Skip: performs common bitwise pre-processing operations using a simple-yet-powerful \"take, skip\" syntax Bit Error: injects bit errors into the data Symbol Remapper: maps n-bit \"symbols\" to other n-bit \"symbols\" Header Framer: frames the data on a given constant header sequence Extractor: extracts bits within and/or around a selected bit range highlight Python Runner: runs a custom Python script using the hobbits Python API Importer/Exporters Importer/Exporters are the primary way to get bitstreams in and out of hobbits. File Data: import bits from or export bits to a file on the filesystem HTTP Data: import bits from or export bits to an HTTP URL Hex String: import bits from or export bits to an ASCII string of hex characters that represent the bits TCP Data: import bits by listening for TCP data on a specified port, or export bits to a TCP server at a specified address LFSR: generates LFSR bits based on given parameters (import only) Packet Capture: captures packets using libpcap (import only) Display Print: exports a display as an image file (export only) Batches When a user develops a sequence of operations that they want to perform frequently, they can save it as a \"Batch\" and perform it later with a single step. Batches can also be used to process bits on the command line with the hobbits-runner CLI. Technical Architecture The rest of this document covers the technical architecture of the Hobbits platform. Challenges The architecture of Hobbits is best understood through the lens of the challenges it faces in satisfying its user goals. Required capabilities are unpredictable The problem space that can be approached with a \"bitwise analysis, processing, and visualization\" tool is vast, even when scoped to a specific domain like high-speed networks. Hobbits must be prepared for unexpected features. Required capabilities are numerous A large problem space also leads to a large number of capabilities being integrated, and each newly integrated capability beckons adjacent capabilities to be integrated, and so on. Hobbits must be prepared for a lot of features. Required capabilities are performance-intensive When working with large amounts of data at the bit level, it is critical to use processing cycles and memory efficiently. An effective interface and core library needs to ensure that simple capabilities have efficient abstractions available, while high-performance capabilities are unencumbered by abstraction. Hobbits must provide lean interfaces and fast utilities. Implemented capabilities need to work together Decoupling capabilities from one another in a plugin system makes it harder for them to coordinate with each other and create the smoothest experience possible. Hobbits must provide ways of orchestrating multiple plugins cleanly, and the plugin interface must allow safe, opportunistic coordination between plugins. Solutions C++/Qt Using C++ and the Qt framework as the foundation for Hobbits makes it easier to meet performance requirements, and trivializes the process of turning existing C/C++ programs into plugins. This is useful because many performance-critical data analysis and processing capabilities are written in C/C++. Qt enables rapid GUI design as well as a variety of well-documented convenience tools, such as a plugin loading system. Python Allowing plugins to leverage or be completely written in Python enables users and developers to prioritize flexibility and development speed when C++ is too cumbersome. It also lets plugins take advantage of the wealth of existing Python packages. Plugin System As mentioned above, all analysis, processing, and visualization capabilities of Hobbits are provided dynamically with plugins. This makes it easy to add new and unexpected capabilities without increasing the complexity of adding more new and unexpected capabilities. This kind of development scaling can be achieved without plugins, but plugins guarantee it. Furthemore, plugins enable the program to be extended without any updates to the core program. The plugin interfaces grant a lot of implementation flexibility while maintaining a narrow, inflexible coupling to the core program. The flexibility enables the addition of unpredictable capabilities, while the clear coupling enables useful integration between plugins. Another important consideration of the plugin system design was implementation speed and ease. Adding new plugins needs to be fast and painless. The simplicity of the essential interface components helps with this, but the core library utilities and the plugin templates are also very important. Finally, a plugin system allows Mahlet (or any other organization) to develop plugins that can be used internally, or licensed and sold separately from the core Hobbits open-source project. Core Library The core library's main purpose is to provide useful tools and abstractions for the plugin implementations. This includes ways of accessing and operating on packed bits, ways of drawing common display primitives, and other conveniences. The core library also contains useful capabilities for managing the integration of different plugins in a sensible way. The Hobbits GUI relies heavily on these default integration managers, and as a result is fairly compact. Other applications would be able to similarly leverage the core library, so custom Hobbits command line utilities and processing servers could feasibly be created (or added to existing programs) in a matter of hours rather than days/weeks. Templates Even with rigorous simplification of the plugin interfaces and useful abstractions of the Qt plugin loader, there is still a small amount of boilerplate code required when making a plugin. This boilerplate code can be annoying to experienced developers, and it can be intimidating to developers that are unfamiliar with the program. Templates, in the form of Qt Creator wizards, are available to set up all of the boilerplate code required to make a functioning plugin. This dramatically speeds up the development of new plugins, especially simple plugins, and plugins that just wrap existing C/C++ processing capabilities.","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#summary","text":"Hobbits is a software platform for analyzing, processing, and visualizing bits. The Hobbits GUI is the central tool of the platform, and will be the primary focus of this document. The Hobbits Runner CLI enables the execution of plugins and batches without a GUI.","title":"Summary"},{"location":"#why","text":"Hobbits was developed to accelerate manual data analysis tasks that were starting to burden Mahlet's hardware and software development. The de facto solution involved the use of multiple tools with slow turnaround and improvised integration (e.g. custom Python scripts and xxd.) Hobbits provided a fully integrated analysis environment without sacrificing flexibility. As a result, it has quickly accumulated success stories across the different development teams. There are tools that are similar to Hobbits, but none can claim to be as extensible, portable, and flexible. GUI and plugin binaries can be easily dropped, swapped, and executed on a variety of platforms without dependencies or restrictions. Hobbits even supports pure Python plugins via a built-in CPython interpreter and custom hobbits library bindings. These are all priceless advantages when developing analysis tradecraft across a variety of communities, networks, or access levels.","title":"Why?"},{"location":"#what-now","text":"The general architecture of Hobbits has proven to be highly effective and agile, and the budding Python capabilities are promising. With a stable interface in place, the development priorities will shift to core stability and performance, adding and improving plugins, and exploring the possibilities of distributed and client-server architectures.","title":"What Now?"},{"location":"#hobbits-gui","text":"The primary concern of Hobbits GUI is making machine-level data presentable to humans so that they can analyze/fix/generate it easily. This usually involves some combination of: Importing bits, e.g. from files, packets, or a radio interface Analyzing bits, e.g. framing, highlighting, or classifying Displaying bits so that a human can understand them Processing bits, e.g. enriching, decoding, or demuxing them Exporting bits, e.g. saving a file, or forwarding to follow-on processes Hobbits simplifies the task of developing and repeating workflows comprised of these steps. Steps are developed independently as plugins, and Hobbits orchestrates their execution.","title":"Hobbits GUI"},{"location":"#capabilities-via-plugins","text":"The importing, analyzing, displaying, processing, and exporting capabilities of Hobbits are provided dynamically with plugins. (The plugin system is described in depth here .) While the current collection of capabilities provides a uniquely fast, easy, and portable experience, the true power of the platform lies in its ability add new plugins that further customize and optimize desired workflows. Thoughtful architectural planning and useful development tools allow one to create plugins with C++ or Python in a matter of minutes. The ease of extensibility provided by the plugin system will enable core feature development to proceed rapidly, and even opens up the possibility of externally developed plugin collections.","title":"Capabilities Via Plugins"},{"location":"#displays","text":"Displays are critical because the information bandwidth of the average human optical physiology is very high. Variety and configurability are necessary for showing the most important charactaristics of different types of data. Bit Raster: shows frames of bits as raster lines in which each pixel represents a bit Byte Raster: same as the Bit Raster, but each pixel represents a byte Symbol Raster: same as the Bit Raster, but each pixel is a configurable bit-length \"symbol\" with a correlating custom color Binary: shows frames of bits as lines of binary digits Hex: shows frames of bits as lines of hexadecimal digits ASCII: shows frames of bits as lines of decoded ASCII text Digraph Plot: shows byte adjacency patterns Dot Plot: shows byte repetition patterns Hilbert Plot: shows byte sections in visibly delineated chunks Frequency Plot: shows a histogram of the most common bytes Spectrogram: shows a power spectral density waterfall plot for sampled data","title":"Displays"},{"location":"#analyzers","text":"Analyzers digest and decorate the data in a way that facilitates follow-on processing and/or human evaluation. Analyzers are non-destructive. Find: finds and navigates to bit, hex, octal, and ASCII patterns in the data Width Framer: frames the data to given bit-width. Includes an auto-correlation function and width-picker graph. Highlight: enables highlighting of bit ranges Kaitai Struct: highlights the data sections based on a known/specified binary format Metadata: shows and allows editing of metadata fields","title":"Analyzers"},{"location":"#operators","text":"Operators take some number of data inputs, and produce some number of data outputs. Most operators are 1-in, 1-out, but the flexibility of the interface enables several critical operations (e.g. muxes, demuxes.) The output of operators will go into new containers so that the original data can still be easily referenced. Take Skip: performs common bitwise pre-processing operations using a simple-yet-powerful \"take, skip\" syntax Bit Error: injects bit errors into the data Symbol Remapper: maps n-bit \"symbols\" to other n-bit \"symbols\" Header Framer: frames the data on a given constant header sequence Extractor: extracts bits within and/or around a selected bit range highlight Python Runner: runs a custom Python script using the hobbits Python API","title":"Operators"},{"location":"#importerexporters","text":"Importer/Exporters are the primary way to get bitstreams in and out of hobbits. File Data: import bits from or export bits to a file on the filesystem HTTP Data: import bits from or export bits to an HTTP URL Hex String: import bits from or export bits to an ASCII string of hex characters that represent the bits TCP Data: import bits by listening for TCP data on a specified port, or export bits to a TCP server at a specified address LFSR: generates LFSR bits based on given parameters (import only) Packet Capture: captures packets using libpcap (import only) Display Print: exports a display as an image file (export only)","title":"Importer/Exporters"},{"location":"#batches","text":"When a user develops a sequence of operations that they want to perform frequently, they can save it as a \"Batch\" and perform it later with a single step. Batches can also be used to process bits on the command line with the hobbits-runner CLI.","title":"Batches"},{"location":"#technical-architecture","text":"The rest of this document covers the technical architecture of the Hobbits platform.","title":"Technical Architecture"},{"location":"#challenges","text":"The architecture of Hobbits is best understood through the lens of the challenges it faces in satisfying its user goals.","title":"Challenges"},{"location":"#required-capabilities-are-unpredictable","text":"The problem space that can be approached with a \"bitwise analysis, processing, and visualization\" tool is vast, even when scoped to a specific domain like high-speed networks. Hobbits must be prepared for unexpected features.","title":"Required capabilities are unpredictable"},{"location":"#required-capabilities-are-numerous","text":"A large problem space also leads to a large number of capabilities being integrated, and each newly integrated capability beckons adjacent capabilities to be integrated, and so on. Hobbits must be prepared for a lot of features.","title":"Required capabilities are numerous"},{"location":"#required-capabilities-are-performance-intensive","text":"When working with large amounts of data at the bit level, it is critical to use processing cycles and memory efficiently. An effective interface and core library needs to ensure that simple capabilities have efficient abstractions available, while high-performance capabilities are unencumbered by abstraction. Hobbits must provide lean interfaces and fast utilities.","title":"Required capabilities are performance-intensive"},{"location":"#implemented-capabilities-need-to-work-together","text":"Decoupling capabilities from one another in a plugin system makes it harder for them to coordinate with each other and create the smoothest experience possible. Hobbits must provide ways of orchestrating multiple plugins cleanly, and the plugin interface must allow safe, opportunistic coordination between plugins.","title":"Implemented capabilities need to work together"},{"location":"#solutions","text":"","title":"Solutions"},{"location":"#cqt","text":"Using C++ and the Qt framework as the foundation for Hobbits makes it easier to meet performance requirements, and trivializes the process of turning existing C/C++ programs into plugins. This is useful because many performance-critical data analysis and processing capabilities are written in C/C++. Qt enables rapid GUI design as well as a variety of well-documented convenience tools, such as a plugin loading system.","title":"C++/Qt"},{"location":"#python","text":"Allowing plugins to leverage or be completely written in Python enables users and developers to prioritize flexibility and development speed when C++ is too cumbersome. It also lets plugins take advantage of the wealth of existing Python packages.","title":"Python"},{"location":"#plugin-system","text":"As mentioned above, all analysis, processing, and visualization capabilities of Hobbits are provided dynamically with plugins. This makes it easy to add new and unexpected capabilities without increasing the complexity of adding more new and unexpected capabilities. This kind of development scaling can be achieved without plugins, but plugins guarantee it. Furthemore, plugins enable the program to be extended without any updates to the core program. The plugin interfaces grant a lot of implementation flexibility while maintaining a narrow, inflexible coupling to the core program. The flexibility enables the addition of unpredictable capabilities, while the clear coupling enables useful integration between plugins. Another important consideration of the plugin system design was implementation speed and ease. Adding new plugins needs to be fast and painless. The simplicity of the essential interface components helps with this, but the core library utilities and the plugin templates are also very important. Finally, a plugin system allows Mahlet (or any other organization) to develop plugins that can be used internally, or licensed and sold separately from the core Hobbits open-source project.","title":"Plugin System"},{"location":"#core-library","text":"The core library's main purpose is to provide useful tools and abstractions for the plugin implementations. This includes ways of accessing and operating on packed bits, ways of drawing common display primitives, and other conveniences. The core library also contains useful capabilities for managing the integration of different plugins in a sensible way. The Hobbits GUI relies heavily on these default integration managers, and as a result is fairly compact. Other applications would be able to similarly leverage the core library, so custom Hobbits command line utilities and processing servers could feasibly be created (or added to existing programs) in a matter of hours rather than days/weeks.","title":"Core Library"},{"location":"#templates","text":"Even with rigorous simplification of the plugin interfaces and useful abstractions of the Qt plugin loader, there is still a small amount of boilerplate code required when making a plugin. This boilerplate code can be annoying to experienced developers, and it can be intimidating to developers that are unfamiliar with the program. Templates, in the form of Qt Creator wizards, are available to set up all of the boilerplate code required to make a functioning plugin. This dramatically speeds up the development of new plugins, especially simple plugins, and plugins that just wrap existing C/C++ processing capabilities.","title":"Templates"},{"location":"plugin-developer-guide/","text":"Hobbits Plugin Development The Hobbits framework is designed to coordinate the capabilities of various plugins into a smooth, cohesive experience. The plugins are where all of the \"actual work\" gets done. There are currently four types of plugins in Hobbits: Displays, Analyzers, Operators, and Importer/Exporters. This document will cover general plugin implementation concepts, and then walk through the development process for each type of plugin. Example Plugin Development Video General Terms and Concepts Qt Plugin API Hobbits leverages the low-level plugin API provided by Qt for its plugin system. Refer to the following Qt documentation for details: Low-level Plugin API Deploying Plugins Bit Containers The BitContainer class is the primary means of storing data, and sharing it between plugins. A BitContainer holds binary data, as well as metadata such as how that data is framed. It also keeps a record of any changes that have been made to it by Hobbits plugins. The binary data is held in a BitArray , which abstracts byte boundaries from the user, and has a modest-but-growing assortment of performance efficiencies and helper functions. Metadata is stored in a BitInfo object which is read and written with the bitInfo and setBitInfo methods. The framing of a bitstream is an important part of its metadata for display and processing purposes. The frames of a BitContainer can be set in the BitInfo::setFrames method. General purpose metadata can be set with BitInfo::setMetadata and read with BitInfo::metadata . Plugins can use container metadata as a general purpose bus for communicating with other plugins, or even as a cache for their own purposes. For example, the \"Find\" Analyzer plugin stores the results of a find operation in a container's metadata so that when that container loses focus, the information will still be available when the container comes back into focus. Highlights are a separate kind of metadata that deal with ranges of bits within a bit container. They are read and written with various functions including BitInfo::addHighlights and BitInfo::highlights , and they are stored as a map of strings to RangeHighlight lists. The \"Find\" Analyzer plugin sets highlights in the ranges where it finds its search string, and several Display plugins check for the existence and colors of RangeHighlight s in order to render visual highlights across those ranges. Plugins like the Extractor operator use RangeHighlight s for their processing. Analyzer plugins do not have write access to bit containers, so they cannot edit the BitInfo directly. As a result, they must include a container's updated BitInfo in the AnalyzerResult s that they return. Parameters, Delegates, and Editors Most plugins require customizable parameters in order to perform their function. Parameters are provided as QJsonObject s in the code so that they can be easily serialized. Most plugins provide a ParameterDelegate that provides details and validation capabilities for the JSON parameters, and optionally provides an implementation of AbstractParameterEditor for editing the parameters in a GUI. For most plugins, it is best to follow the pattern used in the Qt Creator plugin templates that does the following: Create Qt Designed Form class that implementes AbstractParameterEditor Use a ParameterHelper to wrap each of the UI elements for easy QJsonObject getting and setting. Emit AbstractParameterEditor 's changed signal whenever the UI changes. If the editor needs to react to or enrich BitContainer metadata, implement previewBitsUiImpl . previewBitsImpl can also be used for off-thread pre-processing before previewBitsUiImpl is called. In the plugin implementation, create a list of ParameterInfo s that describe the parameters. In the plugin implementation, create the plugin's ParameterDelegate with ParameterDelegate::create using the ParameterInfo list, a std::function that describes the plugin operation based on some parameter set, and another std::function that returns the AbstractParameterEditor implementation. This is the ParameterDelegate that would then get returned in, for example, in AnalyzerInterface::parameterDelegate . Action Progress The ActionProgress parameter is passed to some of the core plugin methods. It allows a plugin to report its percentage progress as it executes, and allows it to check if it has been cancelled so that it can halt execution gracefully. It is possible for this parameter to be null, so plugins should check for that. Threads Many of the main plugin methods will be executed on secondary threads, separate from the the main Qt GUI thread. In those methods, it is important to avoid using general Qt GUI functionality (e.g. creating a QMessageBox pop-up) or the application might crash horribly. Read more about threads and Qt here . Common Plugin Methods Hobbits plugins have a base abstract interface HobbitsPlugin with the following methods: name returns a unique plugin name description returns a description of the plugin tags returns a list of categories that this plugin is affiliated with There is also a common createDefaultX method (where X is the interface type) that simply returns a default instance of the plugin. Specific Interfaces Operator Interface Operators take some number of data inputs, and produce some number of data outputs. Most operators are 1-in, 1-out, but the flexibility of the interface enables several critical operations (e.g. data generators, muxes, demuxes.) The output of operators will go into new containers so that the original data can still be easily referenced. operateOnBits takes a list of read-only bit containers, QJsonObject parameters, and an ActionProgress instance. It returns an OperatorResult which contains any new bit containers that have been created by the operator, and the QJsonObject parameters that will enable the operation to be duplicated exactly. This method may be executed on a secondary thread (see threads guidance above ) getMinInputContainers and getMaxInputContainers return the minimum and maximum number of containers that the operator accepts as inputs. Operators that take a single input and produce a single output would simply return 1 for both of these functions. Analyzer Interface Analyzers digest and decorate the data in a way that facilitates follow-on processing and/or human evaluation. analyzeBits takes a read-only bit container, QJsonObject parameters, and an ActionProgress instance. It returns an AnalyzerResult which contains new general metadata and range entries for the container, and the QJsonObject parameters that will enable the operation to be duplicated exactly. This method may be executed on a secondary thread (see threads guidance above ) Display Interface Displays show the data in some sort of useful format (e.g. a bit raster, or a hex dump.) They can use metadata and highlights in bit containers to augment a depiction of the data, but they could also show only the metadata if that was useful somehow (e.g. if there were some metrics worth presenting separately from the plugin that generated them.) renderConfig returns a DisplayRenderConfig that provides some basic guidance on how the display should be rendered, for example, whether or not it should be rendered asynchronously on a secondary thread. setDisplayHandle is how the plugin receives the shared DisplayHandle which provides access to a variety of things that a display might need to access (e.g. the current bit container), or set (e.g. the bit that is currently being hovered over by the mouse.) It also lets the display set things like the currently displayed range of bits with DisplayHandle::setRenderedRange . renderDisplay is the primary display rendering function that takes the a viewport size, QJsonObject parameters, and an ActionProgress instance. It returns a DisplayResult which contains a QImage and the QJsonObject parameters that will enable the operation to be duplicated exactly. This method may be executed on a secondary thread (see threads guidance above ) renderOverlay is similar to renderDisplay , but it does not receive an ActionProgress . An overlay is generally something that might get adjusted more frequently and separately from the main display, like a hover-over tooltip. It generally is not executed on a secondary thread, but it can be (for example in a DisplayPrinter exporter) Import/Export Interface Import/Export plugins import and/or export bit containers for use in Hobbits. A simple example of an ImporterExporter is the \"File Data\" plugin that imports/exports raw binary data from/to files. canExport and canImport return a boolean value indicating whether or not the plugin is capable of importing or exporting (e.g. you might want a plugin that can import data but not export it.) You can return false in both methods, but that would be impolite. importBits and exportBits both receive QJsonObject parameters, and an ActionProgress instance. exportBits also receives a bit container that should be exported. It returns an ExportResult with the QJsonObject parameters that will enable the operation to be duplicated exactly. importBits returns a non-empty bit container in its ImportResult if it was successful at importing data along with the QJsonObject parameters. Helpful Tools In order to simplify the process of developing plugins, there are Qt Creator wizards that take care of most of the boilerplate code. The wizards can be installed using the wizard_installer.sh script. Get in touch If you are having trouble making a plugin, or if you have a suggestion for the hobbits API or documentation please open an issue on the GitHub page or ask about it on the Discord channel","title":"Plugin Developer Guide"},{"location":"plugin-developer-guide/#hobbits-plugin-development","text":"The Hobbits framework is designed to coordinate the capabilities of various plugins into a smooth, cohesive experience. The plugins are where all of the \"actual work\" gets done. There are currently four types of plugins in Hobbits: Displays, Analyzers, Operators, and Importer/Exporters. This document will cover general plugin implementation concepts, and then walk through the development process for each type of plugin.","title":"Hobbits Plugin Development"},{"location":"plugin-developer-guide/#example-plugin-development-video","text":"","title":"Example Plugin Development Video"},{"location":"plugin-developer-guide/#general-terms-and-concepts","text":"","title":"General Terms and Concepts"},{"location":"plugin-developer-guide/#qt-plugin-api","text":"Hobbits leverages the low-level plugin API provided by Qt for its plugin system. Refer to the following Qt documentation for details: Low-level Plugin API Deploying Plugins","title":"Qt Plugin API"},{"location":"plugin-developer-guide/#bit-containers","text":"The BitContainer class is the primary means of storing data, and sharing it between plugins. A BitContainer holds binary data, as well as metadata such as how that data is framed. It also keeps a record of any changes that have been made to it by Hobbits plugins. The binary data is held in a BitArray , which abstracts byte boundaries from the user, and has a modest-but-growing assortment of performance efficiencies and helper functions. Metadata is stored in a BitInfo object which is read and written with the bitInfo and setBitInfo methods. The framing of a bitstream is an important part of its metadata for display and processing purposes. The frames of a BitContainer can be set in the BitInfo::setFrames method. General purpose metadata can be set with BitInfo::setMetadata and read with BitInfo::metadata . Plugins can use container metadata as a general purpose bus for communicating with other plugins, or even as a cache for their own purposes. For example, the \"Find\" Analyzer plugin stores the results of a find operation in a container's metadata so that when that container loses focus, the information will still be available when the container comes back into focus. Highlights are a separate kind of metadata that deal with ranges of bits within a bit container. They are read and written with various functions including BitInfo::addHighlights and BitInfo::highlights , and they are stored as a map of strings to RangeHighlight lists. The \"Find\" Analyzer plugin sets highlights in the ranges where it finds its search string, and several Display plugins check for the existence and colors of RangeHighlight s in order to render visual highlights across those ranges. Plugins like the Extractor operator use RangeHighlight s for their processing. Analyzer plugins do not have write access to bit containers, so they cannot edit the BitInfo directly. As a result, they must include a container's updated BitInfo in the AnalyzerResult s that they return.","title":"Bit Containers"},{"location":"plugin-developer-guide/#parameters-delegates-and-editors","text":"Most plugins require customizable parameters in order to perform their function. Parameters are provided as QJsonObject s in the code so that they can be easily serialized. Most plugins provide a ParameterDelegate that provides details and validation capabilities for the JSON parameters, and optionally provides an implementation of AbstractParameterEditor for editing the parameters in a GUI. For most plugins, it is best to follow the pattern used in the Qt Creator plugin templates that does the following: Create Qt Designed Form class that implementes AbstractParameterEditor Use a ParameterHelper to wrap each of the UI elements for easy QJsonObject getting and setting. Emit AbstractParameterEditor 's changed signal whenever the UI changes. If the editor needs to react to or enrich BitContainer metadata, implement previewBitsUiImpl . previewBitsImpl can also be used for off-thread pre-processing before previewBitsUiImpl is called. In the plugin implementation, create a list of ParameterInfo s that describe the parameters. In the plugin implementation, create the plugin's ParameterDelegate with ParameterDelegate::create using the ParameterInfo list, a std::function that describes the plugin operation based on some parameter set, and another std::function that returns the AbstractParameterEditor implementation. This is the ParameterDelegate that would then get returned in, for example, in AnalyzerInterface::parameterDelegate .","title":"Parameters, Delegates, and Editors"},{"location":"plugin-developer-guide/#action-progress","text":"The ActionProgress parameter is passed to some of the core plugin methods. It allows a plugin to report its percentage progress as it executes, and allows it to check if it has been cancelled so that it can halt execution gracefully. It is possible for this parameter to be null, so plugins should check for that.","title":"Action Progress"},{"location":"plugin-developer-guide/#threads","text":"Many of the main plugin methods will be executed on secondary threads, separate from the the main Qt GUI thread. In those methods, it is important to avoid using general Qt GUI functionality (e.g. creating a QMessageBox pop-up) or the application might crash horribly. Read more about threads and Qt here .","title":"Threads"},{"location":"plugin-developer-guide/#common-plugin-methods","text":"Hobbits plugins have a base abstract interface HobbitsPlugin with the following methods: name returns a unique plugin name description returns a description of the plugin tags returns a list of categories that this plugin is affiliated with There is also a common createDefaultX method (where X is the interface type) that simply returns a default instance of the plugin.","title":"Common Plugin Methods"},{"location":"plugin-developer-guide/#specific-interfaces","text":"","title":"Specific Interfaces"},{"location":"plugin-developer-guide/#operator-interface","text":"Operators take some number of data inputs, and produce some number of data outputs. Most operators are 1-in, 1-out, but the flexibility of the interface enables several critical operations (e.g. data generators, muxes, demuxes.) The output of operators will go into new containers so that the original data can still be easily referenced. operateOnBits takes a list of read-only bit containers, QJsonObject parameters, and an ActionProgress instance. It returns an OperatorResult which contains any new bit containers that have been created by the operator, and the QJsonObject parameters that will enable the operation to be duplicated exactly. This method may be executed on a secondary thread (see threads guidance above ) getMinInputContainers and getMaxInputContainers return the minimum and maximum number of containers that the operator accepts as inputs. Operators that take a single input and produce a single output would simply return 1 for both of these functions.","title":"Operator Interface"},{"location":"plugin-developer-guide/#analyzer-interface","text":"Analyzers digest and decorate the data in a way that facilitates follow-on processing and/or human evaluation. analyzeBits takes a read-only bit container, QJsonObject parameters, and an ActionProgress instance. It returns an AnalyzerResult which contains new general metadata and range entries for the container, and the QJsonObject parameters that will enable the operation to be duplicated exactly. This method may be executed on a secondary thread (see threads guidance above )","title":"Analyzer Interface"},{"location":"plugin-developer-guide/#display-interface","text":"Displays show the data in some sort of useful format (e.g. a bit raster, or a hex dump.) They can use metadata and highlights in bit containers to augment a depiction of the data, but they could also show only the metadata if that was useful somehow (e.g. if there were some metrics worth presenting separately from the plugin that generated them.) renderConfig returns a DisplayRenderConfig that provides some basic guidance on how the display should be rendered, for example, whether or not it should be rendered asynchronously on a secondary thread. setDisplayHandle is how the plugin receives the shared DisplayHandle which provides access to a variety of things that a display might need to access (e.g. the current bit container), or set (e.g. the bit that is currently being hovered over by the mouse.) It also lets the display set things like the currently displayed range of bits with DisplayHandle::setRenderedRange . renderDisplay is the primary display rendering function that takes the a viewport size, QJsonObject parameters, and an ActionProgress instance. It returns a DisplayResult which contains a QImage and the QJsonObject parameters that will enable the operation to be duplicated exactly. This method may be executed on a secondary thread (see threads guidance above ) renderOverlay is similar to renderDisplay , but it does not receive an ActionProgress . An overlay is generally something that might get adjusted more frequently and separately from the main display, like a hover-over tooltip. It generally is not executed on a secondary thread, but it can be (for example in a DisplayPrinter exporter)","title":"Display Interface"},{"location":"plugin-developer-guide/#importexport-interface","text":"Import/Export plugins import and/or export bit containers for use in Hobbits. A simple example of an ImporterExporter is the \"File Data\" plugin that imports/exports raw binary data from/to files. canExport and canImport return a boolean value indicating whether or not the plugin is capable of importing or exporting (e.g. you might want a plugin that can import data but not export it.) You can return false in both methods, but that would be impolite. importBits and exportBits both receive QJsonObject parameters, and an ActionProgress instance. exportBits also receives a bit container that should be exported. It returns an ExportResult with the QJsonObject parameters that will enable the operation to be duplicated exactly. importBits returns a non-empty bit container in its ImportResult if it was successful at importing data along with the QJsonObject parameters.","title":"Import/Export Interface"},{"location":"plugin-developer-guide/#helpful-tools","text":"In order to simplify the process of developing plugins, there are Qt Creator wizards that take care of most of the boilerplate code. The wizards can be installed using the wizard_installer.sh script.","title":"Helpful Tools"},{"location":"plugin-developer-guide/#get-in-touch","text":"If you are having trouble making a plugin, or if you have a suggestion for the hobbits API or documentation please open an issue on the GitHub page or ask about it on the Discord channel","title":"Get in touch"},{"location":"python-plugins/","text":"Python Plugin Developer Guide Python plugins let you rapidly extend hobbits processing abilities with Python code. Hobbits has a built-in interpreter, and a Python API that allows you to process data at near-native speeds while still taking full advantage of the flexibility and power of Python. Basic Plugin Structure Plugins are broken into 2 main parts: A JSON file describing the plugin A Python script implementing the described plugin Plugin Installation Python plugins can be installed in python_displays , python_analyzers , python_operators , or python_importers folders wherever hobbits searches for plugins (e.g. ~/.local/share/hobbits/plugins or the plugins folder adjacent to the hobbits binary.) For example, you could add display plugin files like: ~/.local/share/hobbits/plugins/python_displays/MyPyDisplay/plugin.json ~/.local/share/hobbits/plugins/python_displays/MyPyDisplay/plugin.py JSON File Structure The JSON file should provide the following fields: name - the name of the plugin (string) description - a brief description of the plugin (string) tags - tags for categorizing the plugin (array of strings) script - the name of the python file with the implementation code (string) type - the type of the plugin ( \"importer\" , \"operator\" , or \"analyzer\" ) extra_paths - directories on the local machine where supporting python files/libraries can be found (array of strings) parameters - the parameters that are required by the plugin. It is an array of parameter objects, each of which contains a name field (string) and a type field ( \"string\" , \"integer\" , \"decimal\" , or \"boolean\" ) Here's an example JSON file: { \"name\": \"String Importer\", \"description\": \"Simple example string importer\", \"tags\": [\"Example\"], \"script\": \"plugin.py\", \"type\": \"importer\", \"extra_paths\": [], \"parameters\": [ { \"name\": \"my_string\", \"type\": \"string\" } ] } Display plugins can optionally set their render_config (default values shown): { ... \"type\": \"display\", \"render_config\": { \"asynchronous\": true, \"hide_bit_offset_controls\": false, \"hide_frame_offset_controls\": false }, ... } Python Script Structure The Python script must be valid Python, and it must define a valid entry point function based on the JSON configuration of the plugin. For example, a valid script for the \"String Importer\" above could be: def import_bits(bits, info, my_string, progress): bits.set_bytes(0, my_string.encode('ascii')) In general terms, a Python plugin with a type of \"importer\" must have a function named import_bits that takes the following parameters (in order): A hobbits.BitArray that will be the imported bits A hobbits.BitInfo that will be the imported bits info/metadata A parameter for each parameter object specified in the \"parameters\" array of the JSON configuration A hobbits.ActionProgess that can be used to update progress and check for cancellation Similarly, an \"analyzer\" type plugin must have a function named analyze_bits that takes: A hobbits.ImmutableBitContainer that will contain the bits and info to be analyzed A hobbits.BitInfo that will be the new info for the bits post-analysis A parameter for each parameter object specified in the \"parameters\" array of the JSON configuration A hobbits.ActionProgess that can be used to update progress and check for cancellation Similarly, an \"operator\" type plugin must have a function named operate_on_bits that takes: A hobbits.ImmutableBitContainer that will contain the bits and info to be operated on A hobbits.BitArray that will be the output bits of the operation A hobbits.BitInfo that will be the output bits info of the operation A parameter for each parameter object specified in the \"parameters\" array of the JSON configuration A hobbits.ActionProgess that can be used to update progress and check for cancellation A \"display\" type plugin must have a function named render_display that takes: A hobbits.DisplayHandle that will contain the bit container and offsets A hobbits.ImageBuffer that will have a size and should be filled with raw ARGB image data A parameter for each parameter object specified in the \"parameters\" array of the JSON configuration A hobbits.ActionProgess that can be used to update progress and check for cancellation Hobbits Python API hobbits.BitContainer BitContainer.bits gets a hobbits.ImmutableBitArray BitContainer.info gets a hobbits.BitInfo hobbits.ImmutableBitContainer returns a hobbits.ImmutableBitInfo for the info property hobbits.BitArray BitArray.size returns the size of the BitArray in bits BitArray.at(i) returns the value of the i th bit BitArray.resize(n) resizes the BitArray to length n BitArray.set(i, x) sets the i th bit to boolean value x BitArray.read_bytes(i, n) reads n bytes starting from the i th byte and returns the value as a Python bytearray BitArray.set_bytes(i, x) writes bytearray x to the BitArray starting at the i th byte BitArray.write_to(fname) writes the contents of the BitArray to a file named fname BitArray.read_from(i, fname) reads the contents of the file named fname into the BitArray starting at the BitArray 's i th byte hobbits.ImmutableBitArray only supports size , at , read_bytes , and write_to hobbits.BitInfo BitInfo.set_metadata(key, value) sets the metadata key to value ( key and value are both strings) BitInfo.get_metadata(key) gets the metadata value of key if it is set (returns empty string if not set) BitInfo.add_highlight(category, label, start, end, color=0x44ff8800) adds a RangeHighlight from bit start to end BitInfo.get_highlights(category) gets a list of all RangeHighlights of category category hobbits.ImmutableBitInfo only supports get_metadata and get_highlights hobbits.ActionProgess ActionProgess.is_cancelled() returns true if the plugin action was cancelled and should be aborted ActionProgress.set_progress_percent(x) reports the progress of the plugin action as x out of 100 ActionProgress.set_progress(x, n) reports the progress of the plugin action as x out of n hobbits.DisplayHandle DisplayHandle.current_container the BitContainer that should be displayed DisplayHandle.bit_offset the current bit offset DisplayHandle.frame_offset the current frame offset DisplayHandle.total_bit_offset the total bit offset (start of offset frame + bit offset) hobbits.ImageBuffer ImageBuffer.set_bytes(x) sets the image data to bytes-like object x (should be 4 * width * height long) ImageBuffer.width width of the image (read-only) ImageBuffer.height the height of the image (read-only)","title":"Python Plugin Developer Guide"},{"location":"python-plugins/#python-plugin-developer-guide","text":"Python plugins let you rapidly extend hobbits processing abilities with Python code. Hobbits has a built-in interpreter, and a Python API that allows you to process data at near-native speeds while still taking full advantage of the flexibility and power of Python.","title":"Python Plugin Developer Guide"},{"location":"python-plugins/#basic-plugin-structure","text":"Plugins are broken into 2 main parts: A JSON file describing the plugin A Python script implementing the described plugin","title":"Basic Plugin Structure"},{"location":"python-plugins/#plugin-installation","text":"Python plugins can be installed in python_displays , python_analyzers , python_operators , or python_importers folders wherever hobbits searches for plugins (e.g. ~/.local/share/hobbits/plugins or the plugins folder adjacent to the hobbits binary.) For example, you could add display plugin files like: ~/.local/share/hobbits/plugins/python_displays/MyPyDisplay/plugin.json ~/.local/share/hobbits/plugins/python_displays/MyPyDisplay/plugin.py","title":"Plugin Installation"},{"location":"python-plugins/#json-file-structure","text":"The JSON file should provide the following fields: name - the name of the plugin (string) description - a brief description of the plugin (string) tags - tags for categorizing the plugin (array of strings) script - the name of the python file with the implementation code (string) type - the type of the plugin ( \"importer\" , \"operator\" , or \"analyzer\" ) extra_paths - directories on the local machine where supporting python files/libraries can be found (array of strings) parameters - the parameters that are required by the plugin. It is an array of parameter objects, each of which contains a name field (string) and a type field ( \"string\" , \"integer\" , \"decimal\" , or \"boolean\" ) Here's an example JSON file: { \"name\": \"String Importer\", \"description\": \"Simple example string importer\", \"tags\": [\"Example\"], \"script\": \"plugin.py\", \"type\": \"importer\", \"extra_paths\": [], \"parameters\": [ { \"name\": \"my_string\", \"type\": \"string\" } ] } Display plugins can optionally set their render_config (default values shown): { ... \"type\": \"display\", \"render_config\": { \"asynchronous\": true, \"hide_bit_offset_controls\": false, \"hide_frame_offset_controls\": false }, ... }","title":"JSON File Structure"},{"location":"python-plugins/#python-script-structure","text":"The Python script must be valid Python, and it must define a valid entry point function based on the JSON configuration of the plugin. For example, a valid script for the \"String Importer\" above could be: def import_bits(bits, info, my_string, progress): bits.set_bytes(0, my_string.encode('ascii')) In general terms, a Python plugin with a type of \"importer\" must have a function named import_bits that takes the following parameters (in order): A hobbits.BitArray that will be the imported bits A hobbits.BitInfo that will be the imported bits info/metadata A parameter for each parameter object specified in the \"parameters\" array of the JSON configuration A hobbits.ActionProgess that can be used to update progress and check for cancellation Similarly, an \"analyzer\" type plugin must have a function named analyze_bits that takes: A hobbits.ImmutableBitContainer that will contain the bits and info to be analyzed A hobbits.BitInfo that will be the new info for the bits post-analysis A parameter for each parameter object specified in the \"parameters\" array of the JSON configuration A hobbits.ActionProgess that can be used to update progress and check for cancellation Similarly, an \"operator\" type plugin must have a function named operate_on_bits that takes: A hobbits.ImmutableBitContainer that will contain the bits and info to be operated on A hobbits.BitArray that will be the output bits of the operation A hobbits.BitInfo that will be the output bits info of the operation A parameter for each parameter object specified in the \"parameters\" array of the JSON configuration A hobbits.ActionProgess that can be used to update progress and check for cancellation A \"display\" type plugin must have a function named render_display that takes: A hobbits.DisplayHandle that will contain the bit container and offsets A hobbits.ImageBuffer that will have a size and should be filled with raw ARGB image data A parameter for each parameter object specified in the \"parameters\" array of the JSON configuration A hobbits.ActionProgess that can be used to update progress and check for cancellation","title":"Python Script Structure"},{"location":"python-plugins/#hobbits-python-api","text":"","title":"Hobbits Python API"},{"location":"python-plugins/#hobbitsbitcontainer","text":"BitContainer.bits gets a hobbits.ImmutableBitArray BitContainer.info gets a hobbits.BitInfo hobbits.ImmutableBitContainer returns a hobbits.ImmutableBitInfo for the info property","title":"hobbits.BitContainer"},{"location":"python-plugins/#hobbitsbitarray","text":"BitArray.size returns the size of the BitArray in bits BitArray.at(i) returns the value of the i th bit BitArray.resize(n) resizes the BitArray to length n BitArray.set(i, x) sets the i th bit to boolean value x BitArray.read_bytes(i, n) reads n bytes starting from the i th byte and returns the value as a Python bytearray BitArray.set_bytes(i, x) writes bytearray x to the BitArray starting at the i th byte BitArray.write_to(fname) writes the contents of the BitArray to a file named fname BitArray.read_from(i, fname) reads the contents of the file named fname into the BitArray starting at the BitArray 's i th byte hobbits.ImmutableBitArray only supports size , at , read_bytes , and write_to","title":"hobbits.BitArray"},{"location":"python-plugins/#hobbitsbitinfo","text":"BitInfo.set_metadata(key, value) sets the metadata key to value ( key and value are both strings) BitInfo.get_metadata(key) gets the metadata value of key if it is set (returns empty string if not set) BitInfo.add_highlight(category, label, start, end, color=0x44ff8800) adds a RangeHighlight from bit start to end BitInfo.get_highlights(category) gets a list of all RangeHighlights of category category hobbits.ImmutableBitInfo only supports get_metadata and get_highlights","title":"hobbits.BitInfo"},{"location":"python-plugins/#hobbitsactionprogess","text":"ActionProgess.is_cancelled() returns true if the plugin action was cancelled and should be aborted ActionProgress.set_progress_percent(x) reports the progress of the plugin action as x out of 100 ActionProgress.set_progress(x, n) reports the progress of the plugin action as x out of n","title":"hobbits.ActionProgess"},{"location":"python-plugins/#hobbitsdisplayhandle","text":"DisplayHandle.current_container the BitContainer that should be displayed DisplayHandle.bit_offset the current bit offset DisplayHandle.frame_offset the current frame offset DisplayHandle.total_bit_offset the total bit offset (start of offset frame + bit offset)","title":"hobbits.DisplayHandle"},{"location":"python-plugins/#hobbitsimagebuffer","text":"ImageBuffer.set_bytes(x) sets the image data to bytes-like object x (should be 4 * width * height long) ImageBuffer.width width of the image (read-only) ImageBuffer.height the height of the image (read-only)","title":"hobbits.ImageBuffer"},{"location":"user-guide/","text":"Using the Hobbits GUI The Hobbits GUI is a powerful tool for manually evaluating data. It provides a fully integrated set of tools for preprocessing, analyzing, and displaying data in a variety of ways. This guide explains how to use the different features of the Hobbits GUI, and then presents a few example workflows. Example Usage Video GUI Layout Bit Container Selection Panel Displays Analyzer Panel Controls for the Displays Operator Panel Preferences Menu Navigating to Edit->Preferences... opens the preferences dialog where the application configuration can be viewed and edited. Bit Containers Hobbits organizes imported data into \"bit containers\" that appear in a collapsible panel on the left side of the GUI by default. The panel's visibility can be toggled via: The top menu at View->Bit Containers The Ctrl-Shift-B hotkey The x at the top right corner of the panel (only for hiding) Bit containers keep track of the data as well as metadata that can be extended, modified, and read by plugins. An important part of this metadata is the \"frames\" that the data is subdivided into. For example, when looking at time-division multiplexed data in a bit raster, it is useful to have each multiplexer frame on its own line so that constants, counters, and other patterns can be easily identified. Plugins Displays One of the most prominent features of the GUI is the variety of displays that it provides for looking at data. Switching between displays is as simple as selecting the tab of the display that you want to use. Your position in the data is preserved across displays, so you can navigate to a section of your data in one display, and then switch tabs to see what that section looks like in a different display. Displays can also be split so that you can look at more than one display at the same time. Split views can be added or removed via: The top menu in View->Split View The Ctrl-Shift-V hotkey adds a view to the right The Ctrl-Shift-X hotkey removes the rightmost view Operators Operators are displayed in a collapsible panel that appears at the bottom of the GUI by default. The panel's visibility can be toggled via: The top menu at View->Operator Plugins The Ctrl-Shift-O hotkey The x at the top right corner of the panel (only for hiding) Operators can be used to modify, generate, combine, or separate data. A commonly used operator is the Take Skip Operator, which allows you to quickly process data with a simple filtering expression. For example, if you have data that is uninteresting for the first 50 bits of every 256-bit frame, you can perform a s50t206 to skip 50 bits and then take 206 bits for each frame so that you are only left with the last 206 bits of each frame for further evaluation. When an operator modifies data, the original data is still available to work with. Analyzers Analyzers appear in a collapsible panel on the right side of the GUI by default. The panel's visibility can be toggled via: The top menu at View->Analyzer Plugins The Ctrl-A hotkey The x at the top right corner of the panel (only for hiding) Analyzers provide useful information about the data, and can add that information to the current bit container's metadata. For example, you can use the Width Framer to discover appropriate frame widths for data, and then apply one of those widths to the container. You can use the Find analyzer to find instances of bit/byte/ASCII sequences in data, and then highlight and quickly navigate to them. Importer/Exporters Importer/Exporters appear in the File->Import Bits From and File->Export Bits To menus. Importer/Exporters are the primary way to get bitstreams in and out of hobbits. For example, if you want to open a file as bits, selecting the File Data import plugin will let you select a file and then load it in as a Bit Container. Batch Creation and Execution Sequences of operator, analyzer, and importer actions can be saved as \"batches\" that can be executed all at once. You can combine and connect these actions in the Batch Editor by navigating to File->Open Batch Editor . Once you finish editing, you can save the batch to a file from the Batch Editor's menu at File->Save Batch As... . You can also create a batch by selecting either the container that starts an action sequence or the container that ends the sequence and then navigating to File->Save Batch... . This will prompt yout and then open the Batch Editor so that you can verify and save the batch. Saved batches can be executed via File->Apply Batch... . Command line execution When running Hobbits from the command line, a variety of configuration and data loading options are provided. Simply run it with the --help option to see which options are available. The hobbits-runner program can be used to apply a saved Hobbits batch to an input file without needing to open the GUI. Plugin loading A standard Hobbits distributable binary comes with a set of core plugins that should load without any user configuration. However, if you want to use a plugin that is not part of the core distribution, you can either: add it to the appropriate directory in the plugins folder of the distribution folder or ~/.local/share/hobbits/plugins or, use the --extra-plugin-path command line option to specify a folder with non-core plugins in it (remember that a valid plugins folder has analyzers, displays, and operators in their own sub-folders, e.g. my-plugins/displays .) or, specify your plugin path in your GUI config. In Linux, the config is an ini file that can be found at ~/.config/Hobbits/Hobbits GUI.conf , and the plugin path configuration is the path variable in the [Plugins] section. Get in touch If you are having trouble using hobbits, or if you have a suggestion for hobbits or the documentation, please open an issue on the GitHub page or ask about it on the Discord channel","title":"User Guide"},{"location":"user-guide/#using-the-hobbits-gui","text":"The Hobbits GUI is a powerful tool for manually evaluating data. It provides a fully integrated set of tools for preprocessing, analyzing, and displaying data in a variety of ways. This guide explains how to use the different features of the Hobbits GUI, and then presents a few example workflows.","title":"Using the Hobbits GUI"},{"location":"user-guide/#example-usage-video","text":"","title":"Example Usage Video"},{"location":"user-guide/#gui-layout","text":"Bit Container Selection Panel Displays Analyzer Panel Controls for the Displays Operator Panel","title":"GUI Layout"},{"location":"user-guide/#preferences-menu","text":"Navigating to Edit->Preferences... opens the preferences dialog where the application configuration can be viewed and edited.","title":"Preferences Menu"},{"location":"user-guide/#bit-containers","text":"Hobbits organizes imported data into \"bit containers\" that appear in a collapsible panel on the left side of the GUI by default. The panel's visibility can be toggled via: The top menu at View->Bit Containers The Ctrl-Shift-B hotkey The x at the top right corner of the panel (only for hiding) Bit containers keep track of the data as well as metadata that can be extended, modified, and read by plugins. An important part of this metadata is the \"frames\" that the data is subdivided into. For example, when looking at time-division multiplexed data in a bit raster, it is useful to have each multiplexer frame on its own line so that constants, counters, and other patterns can be easily identified.","title":"Bit Containers"},{"location":"user-guide/#plugins","text":"","title":"Plugins"},{"location":"user-guide/#displays","text":"One of the most prominent features of the GUI is the variety of displays that it provides for looking at data. Switching between displays is as simple as selecting the tab of the display that you want to use. Your position in the data is preserved across displays, so you can navigate to a section of your data in one display, and then switch tabs to see what that section looks like in a different display. Displays can also be split so that you can look at more than one display at the same time. Split views can be added or removed via: The top menu in View->Split View The Ctrl-Shift-V hotkey adds a view to the right The Ctrl-Shift-X hotkey removes the rightmost view","title":"Displays"},{"location":"user-guide/#operators","text":"Operators are displayed in a collapsible panel that appears at the bottom of the GUI by default. The panel's visibility can be toggled via: The top menu at View->Operator Plugins The Ctrl-Shift-O hotkey The x at the top right corner of the panel (only for hiding) Operators can be used to modify, generate, combine, or separate data. A commonly used operator is the Take Skip Operator, which allows you to quickly process data with a simple filtering expression. For example, if you have data that is uninteresting for the first 50 bits of every 256-bit frame, you can perform a s50t206 to skip 50 bits and then take 206 bits for each frame so that you are only left with the last 206 bits of each frame for further evaluation. When an operator modifies data, the original data is still available to work with.","title":"Operators"},{"location":"user-guide/#analyzers","text":"Analyzers appear in a collapsible panel on the right side of the GUI by default. The panel's visibility can be toggled via: The top menu at View->Analyzer Plugins The Ctrl-A hotkey The x at the top right corner of the panel (only for hiding) Analyzers provide useful information about the data, and can add that information to the current bit container's metadata. For example, you can use the Width Framer to discover appropriate frame widths for data, and then apply one of those widths to the container. You can use the Find analyzer to find instances of bit/byte/ASCII sequences in data, and then highlight and quickly navigate to them.","title":"Analyzers"},{"location":"user-guide/#importerexporters","text":"Importer/Exporters appear in the File->Import Bits From and File->Export Bits To menus. Importer/Exporters are the primary way to get bitstreams in and out of hobbits. For example, if you want to open a file as bits, selecting the File Data import plugin will let you select a file and then load it in as a Bit Container.","title":"Importer/Exporters"},{"location":"user-guide/#batch-creation-and-execution","text":"Sequences of operator, analyzer, and importer actions can be saved as \"batches\" that can be executed all at once. You can combine and connect these actions in the Batch Editor by navigating to File->Open Batch Editor . Once you finish editing, you can save the batch to a file from the Batch Editor's menu at File->Save Batch As... . You can also create a batch by selecting either the container that starts an action sequence or the container that ends the sequence and then navigating to File->Save Batch... . This will prompt yout and then open the Batch Editor so that you can verify and save the batch. Saved batches can be executed via File->Apply Batch... .","title":"Batch Creation and Execution"},{"location":"user-guide/#command-line-execution","text":"When running Hobbits from the command line, a variety of configuration and data loading options are provided. Simply run it with the --help option to see which options are available. The hobbits-runner program can be used to apply a saved Hobbits batch to an input file without needing to open the GUI.","title":"Command line execution"},{"location":"user-guide/#plugin-loading","text":"A standard Hobbits distributable binary comes with a set of core plugins that should load without any user configuration. However, if you want to use a plugin that is not part of the core distribution, you can either: add it to the appropriate directory in the plugins folder of the distribution folder or ~/.local/share/hobbits/plugins or, use the --extra-plugin-path command line option to specify a folder with non-core plugins in it (remember that a valid plugins folder has analyzers, displays, and operators in their own sub-folders, e.g. my-plugins/displays .) or, specify your plugin path in your GUI config. In Linux, the config is an ini file that can be found at ~/.config/Hobbits/Hobbits GUI.conf , and the plugin path configuration is the path variable in the [Plugins] section.","title":"Plugin loading"},{"location":"user-guide/#get-in-touch","text":"If you are having trouble using hobbits, or if you have a suggestion for hobbits or the documentation, please open an issue on the GitHub page or ask about it on the Discord channel","title":"Get in touch"}]}